from pathlib import Path

from pybroma import Class, Root

from broma_ida.broma.constants import BROMA_PLATFORMS
from broma_ida.class_builder.class_builder import ClassBuilder


class BromaCodegen:
    """Codegen for Broma"""
    FILE_HEADER = """// Generated by BromaIDA, do not modify
#include <array>

#define STR_CONCAT_WRAPPER(a, b) a ## b
#define STR_CONCAT(a, b) STR_CONCAT_WRAPPER(a, b)
#define PAD(size) unsigned char STR_CONCAT(__pad, __LINE__)[size]\n\n"""

    _classes: dict[str, Class]
    _path: Path
    _target_platform: BROMA_PLATFORMS
    _broma_path: Path

    _added_classes: set[str] = set()

    def __init__(
        self,
        platform: BROMA_PLATFORMS,
        broma_classes: dict[str, Class],
        path: Path,
        broma_path: Path
    ):
        self._target_platform = platform
        self._classes = broma_classes
        self._path = path
        self._broma_path = broma_path

    def write(self):
        """Dumps codegenned classes, structs and enums
        to the path supplied in __init__

        Args:
            path (Path): _description_
        """
        with open(
            self._path / "codegen." / f"{self._target_platform}.hpp",
            "w",
            buffering=10*1024*1024
        ) as f:
            f.write(self.FILE_HEADER)

            with open(self._path / "enums.hpp") as enums:
                f.write("// enums.hpp\n")
                for line in enums.readlines():
                    f.write(line)
                f.write("\n\n")

            with open(self._path / "cocos2d.hpp") as cocos:
                f.write("// cocos2d.hpp\n")
                for line in cocos.readlines():
                    f.write(line)
                f.write("\n\n")

            with open(self._path / "fmod.hpp") as fmod:
                f.write("// fmod.hpp\n")
                for line in fmod.readlines():
                    f.write(line)
                f.write("\n\n")

            with open(self._path / "stl_types.hpp") as stl_types:
                f.write("// stl_types.hpp\n")
                for line in stl_types.readlines():
                    if line == """#include "enums.hpp"\n""":
                        continue

                    f.write(line)
                f.write("\n\n")

            with open(self._path / "helpers.hpp") as helpers:
                f.write("// helpers.hpp\n")
                for line in helpers.readlines():
                    f.write(line)
                f.write("\n\n")

            f.flush()

            # now we codegen the Broma file
            f.write("// Broma\n\n")

            f.write("// typdefs\n")
            f.write("using TodoReturn = void; // :troll:\n")
            f.write("\n")

            f.flush()

            f.write("// class fwddec\n")
            for c in self._classes.keys():
                if "::" in c:
                    split_c = c.split("::")

                    if len(split_c) == 2:
                        f.write(f"""namespace {split_c[0]} {{ class {split_c[1]}; }};\n""")
                    elif len(split_c) == 3:
                        f.write(f"""namespace {split_c[0]} {{ namespace {split_c[1]} {{ class {split_c[2]}; }} }}\n""")
                else:
                    f.write(f"class {c};\n")
            f.write("\n")

            f.flush()

            f.write("// extras\n")
            for name, broma_class in Root(
                str(self._broma_path / "Extras.bro")
            ).classesAsDict().items():
                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
            f.write("\n")

            f.flush()

            f.write("// delegates and non-polymorphic classes\n")
            for name, broma_class in self._classes.items():
                if len(broma_class.superclasses) != 0:
                    continue

                self._added_classes.add(name)

                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
            f.write("\n")

            f.flush()

            f.write("// classes\n")
            for name, broma_class in self._classes.items():
                if name in self._added_classes:
                    continue

                f.write(
                    ClassBuilder(self._target_platform, broma_class).get_str()
                )
